# -*- coding: utf-8 -*-
"""Copia de CURSO ALGEBRA LINEAL PYTHON.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1holMpxB6lJdpFLtd2dwAbo94_Khkigti

---
# ***ALGEBRA LINEAL EN PYTHON***
---
"""

# un escalar es solo unnúmero hablando matematicamnete
escalar = 5.89
escalar

# pero en Python un escalar puede ser cualquier "tipo" de dato en el lenguaje! (bool, string, int, float)
escalar_python = True

"""# ***vector vs escalar vs matriz vs tensor***
---
* escalar es un número
* un vector es un conjunto de números (o escalares)
* una matriz es un conjunto de vectores apilados
* por último un tensor es un "conjunto de matrices", es decir nos podemos mover entre matrices tendremos mas grado de libertad a la hora de poder movernos no solo entre filas y columnas como una mtriz sino tambien podremos movernos entre matrices :3
---
"""

# importamos numerical python
import numpy as np
# creamos nuestro vector (una fila)
vector = np.array([1,2,3,4,5,6])
vector

# ahora vamos a crear una matriz (3x3) un conjunto de vectores
matriz = np.array([[1, 2, 3],[4, 5, 6],[7, 8, 9]])
matriz

# ahora  vamos a crear un tensor (conjunto de matrices) ó cómo un cubo de rubik
tensor = np.array([
                [[1, 2, 3],[4, 5, 6],[7, 8, 9]],
                [[1, 2, 3],[4, 5, 6],[7, 8, 9]],
                [[1, 2, 3],[4, 5, 6],[7, 8, 9]]
])
tensor

import matplotlib.pyplot as plt
tensor = np.array([
    [[255,255,255],[255,255,255],[255,255,255]],
    [[0,0,0],[0,0,0],[0,0,0]],
    [[128,128,128],[128,128,128],[128,128,128]]
])
# imshow toma como 1er argumento un tensor para saber de cuantas matrices se compone nuetsro tensor usamos RGB colors :3
plt.imshow(tensor, interpolation = "nearest")
plt.show()

"""---
# ***Dimensiones de un vector, matriz, escalar y tensor***
---
"""

# creamos cada cosa
#escalar
escalar = 56
#vector 
vector = np.array([1, 2, 3, 4])
# matriz de (3x2)
matriz = np.array([[2, 4], [6, 8], [10, 12]])
# tensor 
tensor = np.array([
    [[255,255],[255,255,255],[255,255,255]],
    [[128,128,128],[128,128,128],[128,128,128]],
])

# ahora usaremos el metodo shape que nos retorna las dimensiones de nuestro objetos :3
escalar.shape
# como vemos un escalar no tiene dimensiones

vector.shape # aqui nos damos cuenta que solo tenemos 4 columnas ya que es un vector con 4 numeros

matriz.shape # nos retorna que nuestra matriz efectivamnete es de 3x2 es decir  3 filas y 2 columnas :3

tensor.shape # el shape con tensor toma como 1er salida la cantidad de matrices que cintine tu tensor y por 2do toma la cantidad de filas que hay dentro de cada matriz de tu tensor
# nota retorna solo estos 2 argumentos ya que en ki matriz NO CONTENGO EL MISMO NUMERO DE COLUMNAS PARA LAS 2 MATRICES :3

# ejemplo de tensor cuando mis matrices son identicas todas
tensor = np.array([
    [[255,255,255],[255,255,255],[255,255,255]],
    [[128,128,128],[128,128,128],[128,128,128]],
    [[128,128,128],[128,128,128],[128,128,128]]
])
tensor.shape # esto me retornara (2,3,3) (matrices, filas, columnas) -> tensor

# len() vs size
#len(escalar)  nos arrojara error ya que es un int

# matriz = np.array([[2, 4], [6, 8], [10, 12]]) nuestra matriz
len(matriz) # esto nos retorna la cantidad vectores que tenga nuestra matriz

# el len de tensor nos retorna la cantidad de matrices que contiene nuestro vector
len(tensor)

# ahora haremos lo mismo para cada uno pero usando size
# cuando inetntamos sacarle el size a un int nos arroja un error
#escalar.size


# ahora con un vector
vector.size # nos retorna la cantidad de columnas  que contiene nuestro vector :3

# matriz = np.array([[2, 4], [6, 8], [10, 12]])
matriz.size #el size nos retorn ala multiplicacion de de la cantidad de vectores que hay multiplicadas por el numero de columnas qwue contiene cada vector


# NOTA: CUANDO NO TODOS MIS VECTORES TIENE LA MISMA CANTIDAD DE COLUMNAS EL SIZE M RETORNA SOLO EL NUMERO DE VECTORES QUE ALLA EN MI MATRIZ
matriz = np.array([[2, 4], [6, 8], [10]])
matriz.size

# tensor (3, 3, 3)
tensor.size # si todas nuestra matrices que hay en nuestro tensor son iguales es decir mismo numero de filas y colmunas nos retornara la multiplicacion del shape de nuestro tensor


# ahora probemos en le caso contrario que pasa con shape
tensor = np.array([
    [[255,255],[255,255,255],[255,255,255]],
    [[128,128,128],[128,128,128],[128,128,128]],
    [[128,128,128],[128,128,128],[128,128,128]]
])

# entonces aqui ya no tenemos el mismo numero de columnas de nuestro tensor por lo tanto el size nos retorn la multiplicacion del # de matrices y del # de vectores
# en nuestro caso 3x3 == 9
tensor.size

"""---
# ***Transposición, suma de matrices y escalares***
---
* resumen: tomas cada escalar de tu **matriz_1** y lo sumas con el respectivo escalar de la **matriz_2**
---
* ejemplo hecho código:
---

```
#inicializacion de arrays, uso Numpy solo para iniciarlizar
a = np.array([[1,2],[3,4],[5,6]])
b = np.array([[6,5],[4,3],[2,1]])
c = np.array([[0,0],[0,0],[0,0]])

#suma escalar por escalar con bucles while anidados

i = 0
while (i<3):
  j = 0
  while (j<2):
    c[i][j] = a[i][j] + b[i][j]
    j = j + 1
  i = i + 1

print(a)
print(b)
print(c)
```
---
"""

# NOTAS IMPORTANTES:
# trasponer un vector es : supon que tiene sun vector "horizontal" cuando los transpones este vector va a quedar vertical
# trasponer una matriz es : supon que tienes una matriz de 3x2 despues de transponerla te va quedar de 2x3 es decir las filas y columnas se cambian pero la diagonla de esta va a seguri siendo la misma

vector = np.array([1, 2, 3, 4])

matriz = np.array([[1, 2, 3],[4, 5, 6],[7, 8, 9]])

tensor = np.array([
    [[255,255],[255,255,255],[255,255,255]],
    [[128,128,128],[128,128,128],[128,128,128]],
    [[128,128,128],[128,128,128],[128,128,128]]
])


# vamos a sacar la traspuesta de cada objeto entonces 1ro ya sabemos que la traspuesta de un escalar pues nos dara error asi que no lo haré
# ahora en python para sacar la traspuesta usamo la notacion (.T)

# traspuesta de un vector en python
vector_t = vector.T
vector_t # en python scarale la traspuesta aun vector visualmente quedara igual pero como ya sabemos lo que pasa es que nuestro vector en el fondo va a pasara estar en posicion vertical si estaba horizontal


# ahora saquemos la traspuesta de una matriz :o
matriz_t = matriz.T
matriz_t # cuanod tenemos una matriz con la misma cantidad de filas que de columnas y le sacamos la traspuesta pasa que cada indice de acda columna se va a unir y va a formar un vector y pues va a seguir siendo de 3x3


# ahora que pasa si tenemos una matriz de dsitintos numero de columnas por ejemplo 
matriz = np.array([[1,2],[3,4],[5,7]])
matriz_t = matriz.T
matriz_t # aqui si notamso que el shape de la matriz se ve modificada ya que le estamos sacando la traspuesta




# ahora que pasa con las traspuesta de un tensor

"""

tensor = np.array([
    [[255,255],[255,255,255],[255,255,255]],
    [[128,128,128],[128,128,128],[128,128,128]],
    [[128,128,128],[128,128,128],[128,128,128]]
])
okey nuestro tensor tiene un  shape == (3, 3)
y si le sacamos la traspuesta asi como esta pues no lo scara como tal ya que numpy nos retornara en etsos casos las listas tal cual del tensor
"""

tensor_t = tensor.T
tensor_t # aqui nos damos cuenta que la traspuesta nos retorna meras listas

# redifinamos nuestro tensor en el caso de que todos las matrices sean identicas
tensor = np.array([
    [[255,255, 255],[255,255,255],[255,255,255]],
    [[128,128,128],[128,128,128],[128,128,128]],
    [[129,129,129],[128,128,129],[128,128,129]]
])


# saquemos la taspueste de etse tensor en el cual todas sus matrices son iguales
tensor_t = tensor.T
tensor_t # y si funciona son los resultados que esperamos


# por ultimo en cuanot a transposiciones que pasa cuando sacas la transpuesta d ela transpuesta ?
matriz_t_t = matriz_t.T
matriz_t_t # bueno aqui nos damos cuenta que nos retorna la matriz  original :3 SALU2

# ahora vamos con la suma :3
# si intenatmos sumar matrices de disitnas dimensiones nos arrojara un error deben ser de las mismas dimensiones
# probemos:
matriz_1 = np.array([[2, 4, 6], [5, 6, 6], [7, 8, 6]])
matriz_2 = np.array([[2, 3, 2], [3, 4, 3], [6, 5, 5]])

# efectivamente si intento sumar estas dos matrices obtengo un error ya que no tienen el mismo shape matriz_1 == (3,2) and matriz_2 == (3, 3)
#suma = matriz_1 + matriz_2

# ahora modicquemos nuestras matrices y dale mambo
suma = matriz_1 + matriz_2
suma # si nos realiza la suma con exito :3 ls suma estara en una nueva matriz
suma.shape # (3, 3)->matriz_1 or 2 == (3, 3) ->suma

# ahora sumemos un escalar con una matriz :3
escalar = 5
suma_m_e = matriz_1 + escalar
suma_m_e # la suma se realiza lo que apsa qui es que cada numero d enuetsra matriz se sumara con nuestro ecsalar osea con 5 en este caso :)

# por ultimo como reto haremos la suma de un matriz de 5x 5 con su transpuesta OMG

# cremaos nuestra matriz de 5x5 su shape == 5x5
matriz_5 = np.array([[1, 2, 3, 4, 5], [6, 7, 8, 9, 10], [11, 12, 13, 14, 15], [16, 17, 18, 19, 20], [21, 22, 23, 24, 25]])

#sacamos la transpuesta de esta matriz
matriz_5_t = matriz_5.T

# por ultimo veamos que pasa si sumamos la matriz de 5x5 con su transpuesta :o el shape de la trasnpuesta sigue siendo igual a la original ya que es 5x5
suma = matriz_5 + matriz_5_t
suma



"""---
# ***Suma de matrices y vectores (broadcasting)***
---

* Broadcasting es poder sumar una matriz con un vector de distintas dimensiones etso lo hacemos sacando la transpuesta de la matriz para que se ajuste a nuestro vector :3
---
"""

# ejemplo de broadcasting

# supongamos que no transponemos la matriz  sino el vector
vector = np.array([1, 2]) # el len de numeros del vetcor debe ser euqivalente a la cantidad  de vectores de la matriz que quremos sumar con el vector
matriz = np.array([[2, 2], [4, 4]]) # 2 matrices == len(vector) :)

#intentemos sumar esto asi
suma = matriz.T + vector
suma # 2x2 matriz suma 


# ahora cuanod sumamos un matriz con un escalar lo que se hace es tomara acda numero y sumarlo con el escalar peor por debajo esto fucniona como broadcasting en python
# ejemplo
escalar = 5
# formula 1
suma = matriz + escalar
suma 
# internamnete python hace esto :
#formula 2
suma = matriz + np.array([[5], [5]])
suma
# conclusión : la formula1 es igual a la formula2 :)

"""# ***Producto interno entre una matriz y un vector***
---
"""

matriz = np.array([[2, 2], [4, 4]])
vector = np.array([1, 2])

# aqui mulitpilcamos el vector por la matriz y esto nos retorna otra matriz
# como funcion a esta multiplicacion cojemos el 1er nuemro del vector osea 1 y lo mulitplicamos por el 1er elemento de cada matriz osea 2 y 4 y lo mismo con el numero 2 d el vector lo tomamos y multimos por el 2do numero de cada matriz
mul = matriz * vector


# ahora que pasa si multiplicamos el dot  por la mtriz el producto interno por el vector
mul = matriz.dot(vector)
mul # aqui lo  que hacemos es  tomar el 1er numero del vector y multiplicarlo con el 1er elemento de la matriz y luego asi mismo cone le 2do elementyo tanto del vector como dela matriz y este resultado lo sumamos y ese seri nuestro 1er numero dentro dle vector de salida del resultado

mul = vector * matriz
mul

# multiplicar un matriz por un vector es igual que multiplicar un vector por un matriz
mul = matriz * vector
mul

"""# ***Producto interno entre dos matrices***
---
* Para que el producto interno de dos matrices pueda ser calculado se debe cumplir la siguiente condición: dadas las dimensiones de la matrices 4x3 y 3x2 , la cantidad de columnas de la primer matriz debe ser igual a la cantidad de filas de la segunda matrix. Así el producto interno entre las matrices (4x3 ).dot(3x2) es posible pero el producto interno de las matrices en el siguiente orden: (3x2 ).dot(4x3) no es posible.

* Atentos, las columnas de el primer elemento en este caso A debe ser igual que las filas del segundo elemento en este caso B donde A e suna matriz y B tambien 
---
"""

a = np.array([[1,2,3],[4,5,6],[7,8,9],[10,11,12]])
b = np.array([[1, 2], [3, 4], [5, 6]])

# a.shape == (4, 3)
# b.shape == (3, 2)

# aqui se realiza con exito la multiplicacion de las 2 matrices y porque bueno porque las # filas de la matriz b es == al # de columnas de la matriz a
A = a.dot(b)
A


# ahora si intentamos sacar el porudtco interno de b sobre a nos draa error
#B = b.dot(a)

"""# ***Propiedades de las matrices: la multiplicación de matrices es asociativa y distributiva, no es conmutativa ***
---
 * El producto interno de matrices es:

    * Asociativa: Sí
    * Distributiva: Sí
    * Conmutativa: NO
---
* El producto interno de vectores es:
    * Asociativa: Sí
    * Distributiva: Sí
    * Conmutativa: Sí
---
* Que significa que sea ASOCIATIVA:
    * ejemplo : A * (B * C) = (A * B)*C

* Que significa que sea DISTRIBUTIVA:
    * ejemplo: A *(B + C) = (A * B) + (B * C)

* Que significa que sea CONMUTATIVA:
    * ejemplo: B * C = C * B


---


---
"""



# nota : La ley conmutativa solo aplica en la multiplicación de matrices cuando éstas son matrices cuadradas y al mismo tiempo son matrices diagonales.
# cuadradas se refiere a que las columnas estan en misma cantidad que las filas en la matriz :3
A = np.array([[7, 0, 0, 0], [0, 5, 0, 0], [0, 0, 2, 0], [0, 0, 0, 20]])
B = np.array([[1, 0, 0, 0], [0, 8, 0, 0], [0, 0, 13, 0], [0, 0, 0, 4]])
print(A.dot(B) == B.dot(A))

# Asociativa
C = np.array([[7, 0, 0, 0], [0, 5, 0, 0], [0, 0, 2, 0], [0, 0, 0, 20]]) 
ABC = A.dot(B.dot(C))
AB_C = A.dot(B).dot(C)
ABC == AB_C

#Distrbutiva
D = A.dot(B+C)
E = (A.dot(B))+(A.dot(C))

D == E

F = B.dot(C)
G = C.dot(B)
F == G

# NOTA : DEBO MIRAR CUANOD NO SON CUADRANTES NI DIAGONALES EN ES ECAOS CUANOD SEA CONMUTATIVA ME DARA FALSE 
#salu2